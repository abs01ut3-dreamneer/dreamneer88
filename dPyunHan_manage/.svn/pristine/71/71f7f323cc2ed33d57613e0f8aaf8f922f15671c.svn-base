package kr.or.ddit.controller;

import jakarta.servlet.http.HttpSession;
import kr.or.ddit.service.impl.ContractServiceImpl;
import kr.or.ddit.service.impl.HtmlToPdfServiceImpl;
import kr.or.ddit.service.impl.PdfStampingServiceImpl;
import kr.or.ddit.vo.ContractVO;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

@Controller
@RequestMapping("/contract")
@RequiredArgsConstructor
public class ContractController {

    private final ContractServiceImpl contractServiceImpl;

    private final HtmlToPdfServiceImpl htmlToPdfServiceImpl;

    private final PdfStampingServiceImpl pdfStampingServiceImpl;

    /**
     * 1. 수정 페이지 (View)를 보여주는 메서드
     * - DB(서비스)에서 계약서 내용을 가져와서,
     * - Model에 담아 "write.jsp"로 보냅니다.
     */
//    @GetMapping("/edit")
//    public String editContract(Model model) {
//
//        String currentContent = contractService.getContract();
//
//        // "contractContent"라는 이름으로 jsp파일에 데이터를 전달
//        model.addAttribute("contractContent", currentContent);
//
//        return "contract/write"; // "/WEB-INF/views/write.jsp"를 찾아감
//    }

    @GetMapping("/postContract")
    public String insertContract(){
        return "contract/contwrite";
    }

    @PostMapping("/postContract")
    public String postContract(ContractVO form,RedirectAttributes rttr){


        ContractVO contractVO = contractServiceImpl.postContract(form);

        Long id = contractVO.getId();

        rttr.addAttribute("id",id);

        return "redirect:/contract/edit/{id}";
    }

    @GetMapping("/edit/{id}")
    public String editContract(@PathVariable("id") Long id,Model model) {

        // 3. 서비스 호출 변경:
        //    이제 고정된 ID가 아니라 URL로 받은 'id'를 넘겨줍니다.
        String currentContent = contractServiceImpl.getContract(id);

        model.addAttribute("contractContent", currentContent);

        // (참고) 수정 중인 문서의 ID도 JSP로 넘겨주면 나중에 저장할 때 유용합니다.
        model.addAttribute("id", id);

        return "contract/write";
    }

    @GetMapping("/cont")
    public String Contract(Model model) {

//        String currentContent = contractService.getContract();

        // "contractContent"라는 이름으로 jsp파일에 데이터를 전달
//        model.addAttribute("contractContent", currentContent);
//
         // "/WEB-INF/views/write.jsp"를 찾아감
        return "contract/contwrite";
    }

    /**
     * 2. CKEditor에서 '저장' 버튼을 눌렀을 때 실행되는 메서드
     * - "content"라는 이름의 파라미터(HTML 데이터)를 받아서,
     * - 서비스에 넘겨 저장시킵니다.
     * - 저장이 끝나면 다시 수정 페이지로 리다이렉트합니다.
     */
    @PostMapping("/save/{id}")
    public String saveContract(@PathVariable("id") Long id,@RequestParam("content") String content) {

        // CKEditor에서 넘어온 거대한 HTML 문자열을 서비스로 전달
        contractServiceImpl.saveContract(id,content);

        System.out.println(content);

        // 저장 후, 다시 /contract/edit 페이지로 이동시킴 (Post-Redirect-Get 패턴)
        return "redirect:/contract/edit/{id}";
    }

    @PostMapping("/generate-pdf")
    @ResponseBody // (페이지 이동 대신, 생성된 파일의 URL을 JSON/텍스트로 반환)
    public String generateContractPdf(
            @RequestParam("content") String htmlContent, // CKEditor의 name="content"
            HttpSession session) {

        String tempPdfPath = null;
        try {
            // 1단계: HTML -> PDF 파일 생성 (직인 X)
            tempPdfPath = htmlToPdfServiceImpl.createPdfFromHtml(htmlContent);

            // 2단계: 생성된 PDF -> 직인 날인 (직인 O)
            // (이전에 만드신 PDFBox 서비스 호출)
            String finalPdfUrl = pdfStampingServiceImpl.stampServerSeal(
                    tempPdfPath,
                    session.getId() // (세션 ID로 파일명 구분)
            );

            // 3. (선택) 임시 1단계 파일(tempPdfPath)은 삭제
            // ... (new File(tempPdfPath).delete();) ...

            // 4. 클라이언트에게 최종 PDF 파일의 URL 반환
            // (예: "/output/final_contract_...pdf")
            return finalPdfUrl;

        } catch (Exception e) {
            e.printStackTrace();
            // (에러 처리)
            // (만약 tempPdfPath가 생성됐다면 삭제하는 로직 필요)
            return "ERROR: " + e.getMessage();
        }
    }

}
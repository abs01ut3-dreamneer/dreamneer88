package kr.or.ddit.service;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import kr.or.ddit.vo.BizcndIndutyVO;
import kr.or.ddit.vo.CcpyManageVO;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
public class OcrService {
    
    @Value("${naver.ocr.secret-key}")
    private String secretKey;
    
    @Value("${naver.ocr.invoke-url}")
    private String invokeUrl;
    
    @Value("${naver.ocr.domain-name}")
    private String domainName;
    
    private interface FieldExtractor {
        void extract(CcpyManageVO vo, String value);
    }
    
    // ===== 필드별 Extractor 맵 =====
    private final Map<String, FieldExtractor> fieldExtractors = Map.ofEntries(
        Map.entry("ccpyBizrno", (vo, value) -> 
            vo.setCcpyBizrno(extractNumber(value))),        
        Map.entry("ccpyCmpnyNm", (vo, value) -> 
            vo.setCcpyCmpnyNm(extractAfterColon(value))),        
        Map.entry("ccpyRprsntvNm", (vo, value) -> 
            vo.setCcpyRprsntvNm(extractAfterColon(value).replaceAll("\\s+", ""))),        
        Map.entry("ccpyOpbizDe", (vo, value) -> {
            try {
                LocalDate parsedDate = parseLocalDate(value);
                Date convertedDate = convertLocalDateToDate(parsedDate);
                vo.setCcpyOpbizDe(convertedDate);
            } catch (Exception e) {
                log.warn("날짜 파싱 실패: {}", value);
            }
        }),        
        Map.entry("ccpyAdres", (vo, value) -> 
            vo.setCcpyAdres(extractAfterColon(value).replaceAll("^\\s+", "")))
    );
    
    // ===== OCR 처리 메서드 =====
    public JSONObject processBizLicenseOcr(String imagePath) throws Exception {
        
        if (!new File(imagePath).exists()) {
            throw new IllegalArgumentException("파일이 존재하지 않습니다: " + imagePath);
        }
        
        String boundary = "----" + UUID.randomUUID().toString().replaceAll("-", "");
        URL url = new URL(invokeUrl);
        HttpURLConnection con = (HttpURLConnection) url.openConnection();
        
        con.setUseCaches(false);
        con.setDoInput(true);
        con.setDoOutput(true);
        con.setReadTimeout(30000);
        con.setRequestMethod("POST");
        con.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + boundary);
        con.setRequestProperty("X-OCR-SECRET", secretKey);
        
        // 요청 JSON 생성 및 전송
        JSONObject requestJson = createRequestJson();
        sendMultipartRequest(con, boundary, requestJson.toString(), imagePath);
        
        // 응답 수신
        JSONObject ocrResponse = receiveResponse(con);
        return ocrResponse;
    }
    
    // ===== 메인 추출 메서드 =====
    public CcpyManageVO extractCcpyManageVO(JSONObject ocrResult) throws Exception {
        CcpyManageVO ccpyManageVO = new CcpyManageVO();
        
        JSONArray images = (JSONArray) ocrResult.get("images");
        if (images == null || images.isEmpty()) {
            return ccpyManageVO;
        }
        
        JSONObject imageResult = (JSONObject) images.get(0);
        JSONArray fields = (JSONArray) imageResult.get("fields");
        
        if (fields == null) {
            return ccpyManageVO;
        }
        
        List<String> bizcndList = new ArrayList<>();
        List<String> indutyList = new ArrayList<>();
        
        // ===== for-each: 각 필드 처리 =====
        for (Object field : fields) {
            JSONObject fieldObj = (JSONObject) field;
            String fieldName = (String) fieldObj.get("name");
            String fieldValue = (String) fieldObj.get("inferText");
            
            // null/empty 체크
            if (fieldName == null || fieldName.trim().isEmpty() ||
                fieldValue == null || fieldValue.trim().isEmpty()) {
                continue;
            }
            
            // ===== Map에서 조회 후 실행 =====
            if (fieldExtractors.containsKey(fieldName)) {
                fieldExtractors.get(fieldName).extract(ccpyManageVO, fieldValue);
            } 
            // ===== bizcndNm, indutyNm은 별도 처리 =====
            else if ("bizcndNm".equals(fieldName)) {
                collectListField(fieldValue, bizcndList);
            } 
            else if ("indutyNm".equals(fieldName)) {
                collectListField(fieldValue, indutyList);
            }
        }
        
        // ===== 업태/업종 VO 생성 및 추가 =====
        ccpyManageVO.setBizcndIndutyVOList(
            createBizcndIndutyList(bizcndList, indutyList)
        );
        
        return ccpyManageVO;
    }
    
    // ===== 리스트 필드 수집 헬퍼 =====
    private void collectListField(String fieldValue, List<String> targetList) {
        String[] items = fieldValue.split("\n");
        for (String item : items) {
            String trimmed = item.trim();
            if (!trimmed.isEmpty()) {
                targetList.add(trimmed);
            }
        }
    }
    
    // ===== 날짜 변환 =====
    private Date convertLocalDateToDate(LocalDate localDate) {
        if (localDate == null) return null;
        return java.sql.Date.valueOf(localDate);
    }
    
    // ===== 업태/업종 VO 리스트 생성 =====
    private List<BizcndIndutyVO> createBizcndIndutyList(
        List<String> bizcndList, 
        List<String> indutyList) {
        
        List<BizcndIndutyVO> bizcndIndutyVOList = new ArrayList<>();
        
        int maxSize = Math.max(bizcndList.size(), indutyList.size());
        
        for (int i = 0; i < maxSize; i++) {
            BizcndIndutyVO bizcndIndutyVO = new BizcndIndutyVO();
            
            if (i < bizcndList.size()) {
                bizcndIndutyVO.setBizcndNm(bizcndList.get(i));
            }
            if (i < indutyList.size()) {
                bizcndIndutyVO.setIndutyNm(indutyList.get(i));
            }
            
            bizcndIndutyVOList.add(bizcndIndutyVO);
            log.info("check : bizcndIndutyVO => {}", bizcndIndutyVO);
        }
        
        return bizcndIndutyVOList;
    }
    
    // ===== OCR 요청 JSON 생성 =====
    private JSONObject createRequestJson() {
        JSONObject json = new JSONObject();
        json.put("version", "V2");
        json.put("requestId", UUID.randomUUID().toString());
        json.put("timestamp", System.currentTimeMillis());
        
        JSONObject image = new JSONObject();
        image.put("format", "jpg");
        image.put("name", domainName);
        
        JSONArray images = new JSONArray();
        images.add(image);
        json.put("images", images);
        
        return json;
    }
    
    // ===== Multipart 요청 전송 =====
    private void sendMultipartRequest(HttpURLConnection con, String boundary, 
                                     String message, String imagePath) throws Exception {
        try (DataOutputStream wr = new DataOutputStream(con.getOutputStream())) {
            // 메시지 부분
            wr.writeBytes("--" + boundary + "\r\n");
            wr.writeBytes("Content-Disposition: form-data; name=\"message\"\r\n\r\n");
            wr.writeBytes(message + "\r\n");
            
            // 파일 부분
            File file = new File(imagePath);
            wr.writeBytes("--" + boundary + "\r\n");
            wr.writeBytes("Content-Disposition: form-data; name=\"file\"; filename=\"" + 
                          file.getName() + "\"\r\n");
            wr.writeBytes("Content-Type: application/octet-stream\r\n\r\n");
            
            try (FileInputStream fis = new FileInputStream(file)) {
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead = fis.read(buffer)) != -1) {
                    wr.write(buffer, 0, bytesRead);
                }
            }
            
            wr.writeBytes("\r\n--" + boundary + "--\r\n");
            wr.flush();
        }
    }
    
    // ===== OCR 응답 수신 =====
    private JSONObject receiveResponse(HttpURLConnection con) throws Exception {
        int responseCode = con.getResponseCode();
        log.info("check : responseCode => {} ", responseCode);
        
        try (BufferedReader br = new BufferedReader(
            new InputStreamReader(responseCode == 200 ? 
                con.getInputStream() : con.getErrorStream()))) {
            
            StringBuilder response = new StringBuilder();
            String line;
            while ((line = br.readLine()) != null) {
                response.append(line);
            }
            
            JSONParser parser = new JSONParser();
            return (JSONObject) parser.parse(response.toString());
        }
    }
    
    // ===== 텍스트 추출 유틸리티 =====
    private String extractAfterColon(String text) {
        if (text == null) return "";
        
        int colonIndex = text.indexOf(":");
        if (colonIndex == -1) {
            return text.trim();
        }
        
        return text.substring(colonIndex + 1).trim();
    }
    
    // 한글, 숫자, 특정 기호만 남기기
    private String extractKoreanAndNumbers(String text) {
        return text == null ? "" : text.replaceAll("[^가-힣0-9\\-\\s]", "").trim();
    }

    // 한글만 남기기
    private String extractKoreanOnly(String text) {
        return text == null ? "" : text.replaceAll("[^가-힣\\s]", "").trim();
    }

    // 숫자만 남기기
    private String extractNumber(String text) {
        return text == null ? "" : text.replaceAll("[^0-9]", "").trim();
    }
    
    // ===== 날짜 파싱 =====
    private LocalDate parseLocalDate(String dateStr) throws Exception {
        if (dateStr == null) return LocalDate.now();
        
        String cleanDate = dateStr.replaceAll("[^0-9]", "");
        if (cleanDate.length() < 8) return LocalDate.now();
        
        String formatted = cleanDate.substring(0, 4) + "-" + 
                          cleanDate.substring(4, 6) + "-" + 
                          cleanDate.substring(6, 8);
        
        return LocalDate.parse(formatted, DateTimeFormatter.ISO_LOCAL_DATE);
    }
}
